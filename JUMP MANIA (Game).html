


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JUMP MANIA - DELUXE ARENA</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #0b0d17; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; image-rendering: pixelated; }
        #ui { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; pointer-events: none; width: 100%; z-index: 10; }
        .menu { display: inline-block; background: rgba(0, 0, 0, 0.95); padding: 40px; border: 8px solid #55a630; pointer-events: auto; min-width: 400px; }
        h1 { font-size: 70px; margin: 0; color: #ffca3a; text-shadow: 5px 5px #c9184a; }
        .color-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 20px 0; }
        .color-btn { width: 50px; height: 50px; border: 4px solid white; cursor: pointer; }
        .selected { border-color: #ffca3a; transform: scale(1.1); box-shadow: 0 0 15px #ffca3a; }
        button { background: #55a630; border: none; color: white; padding: 15px 30px; font-size: 24px; cursor: pointer; font-family: inherit; margin: 10px; }
        button:hover { background: #ffca3a; color: #000; }
        .hidden { display: none; }
        .setting-row { margin: 15px 0; font-size: 20px; display: flex; justify-content: space-between; align-items: center; }
    </style>
</head>
<body>

<div id="ui">
    <div id="main-menu" class="menu">
        <h1>JUMP MANIA</h1>
        <button onclick="showMenu('color-select')">START BATTLE</button><br>
        <button onclick="showMenu('settings-menu')">SETTINGS</button>
    </div>

    <div id="settings-menu" class="menu hidden">
        <h1>SETTINGS</h1>
        <div class="setting-row"><span>MUSIC</span><button id="mus-btn" onclick="toggleMusic()">ON</button></div>
        <div class="setting-row"><span>SOUNDS</span><button id="sfx-btn" onclick="toggleSFX()">ON</button></div>
        <button onclick="showMenu('main-menu')">BACK</button>
    </div>

    <div id="color-select" class="menu hidden">
        <div style="display:flex; gap: 30px; justify-content: center;">
            <div><div>P1 COLOR</div><div id="p1-colors" class="color-grid"></div></div>
            <div><div>P2 COLOR</div><div id="p2-colors" class="color-grid"></div></div>
        </div>
        <button onclick="startBattle()">BATTLE!</button>
    </div>

    <div id="win-screen" class="menu hidden">
        <h1 id="win-txt">P1 WINS!</h1>
        <button onclick="location.reload()">REMATCH</button>
    </div>
</div>

<canvas id="game"></canvas>

<script>
let audioCtx, musicInterval;
let musicEnabled = true, sfxEnabled = true;
const colors = ['#4caf50', '#f44336', '#2196f3', '#9c27b0', '#ffeb3b', '#ff9800'];
let p1Color = colors[2], p2Color = colors[1];

function initAudio() { if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function toggleMusic() { musicEnabled = !musicEnabled; document.getElementById('mus-btn').innerText = musicEnabled ? 'ON' : 'OFF'; }
function toggleSFX() { sfxEnabled = !sfxEnabled; document.getElementById('sfx-btn').innerText = sfxEnabled ? 'ON' : 'OFF'; }

function playNote(freq, type, duration, vol) {
    if(!audioCtx || !sfxEnabled) return;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    g.gain.setValueAtTime(vol, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
    osc.connect(g); g.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
}

function startMusic() {
    let step = 0;
    musicInterval = setInterval(() => {
        if(gameState !== 'PLAYING' || !musicEnabled) return;
        let bass = vortex.active ? 60 : [110, 110, 130, 146][step % 4];
        playNote(bass, 'triangle', 0.2, 0.05);
        step++;
    }, 250);
}

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let gameState = 'MENU';
const winLimit = 4, zoom = 0.85, keys = {};
let powerup = { x: 0, y: 0, active: false };
let vortex = { x: 0, y: 0, active: false, target: null, angle: 0 };
let clouds = Array.from({length: 8}, () => ({ x: Math.random()*2000, y: Math.random()*400, s: 0.2 + Math.random()*0.5, w: 100 + Math.random()*100 }));

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

function showMenu(id) {
    initAudio();
    document.querySelectorAll('.menu').forEach(m => m.classList.add('hidden'));
    document.getElementById(id).classList.remove('hidden');
    if(id === 'color-select') { setupColorGrid('p1-colors', 1); setupColorGrid('p2-colors', 2); }
}

function setupColorGrid(id, pNum) {
    const grid = document.getElementById(id); grid.innerHTML = '';
    colors.forEach(c => {
        const btn = document.createElement('div'); btn.className = 'color-btn'; btn.style.background = c;
        if((pNum === 1 && p1Color === c) || (pNum === 2 && p2Color === c)) btn.classList.add('selected');
        btn.onclick = () => { if(pNum === 1) p1Color = c; else p2Color = c; setupColorGrid(id, pNum); playNote(440, 'sine', 0.1, 0.05); };
        grid.appendChild(btn);
    });
}

class Player {
    constructor(x, y, controls, pNum) {
        this.startPos = {x, y}; this.w = 120; this.h = 70; this.controls = controls; this.pNum = pNum;
        this.trail = []; this.rotation = 0; this.reset();
    }
    reset() {
        this.x = this.startPos.x; this.y = this.startPos.y;
        this.dx = 0; this.dy = 0; this.isJumping = false; this.canStomp = true; this.dashCD = 0;
        this.face = this.pNum === 1 ? 1 : -1; this.speedBoost = 0; this.rotation = 0;
    }
    update(other) {
        if (vortex.active && vortex.target === this) {
            this.x += (vortex.x - (this.x + this.w/2)) * 0.04;
            this.y += (vortex.y - (this.y + this.h/2)) * 0.04;
            this.rotation += 0.4; return;
        }
        this.rotation = 0;
        let currentSpeed = 6 + (this.speedBoost > 0 ? 5 : 0);
        if(keys[this.controls.dash] && this.dashCD <= 0) { this.dx = this.face * 35; this.dashCD = 60; playNote(800, 'square', 0.1, 0.1); }
        if(this.dashCD > 0) this.dashCD--;
        if(keys[this.controls.left]) { this.dx = -currentSpeed; this.face = -1; }
        else if(keys[this.controls.right]) { this.dx = currentSpeed; this.face = 1; }
        else this.dx *= 0.82;

        if(keys[this.controls.up] && !this.isJumping) { this.dy = -9.5; this.isJumping = true; playNote(300, 'triangle', 0.1, 0.1); }
        if(keys[this.controls.up] && this.dy < 0) this.dy -= 0.42;
        if(keys[this.controls.down] && this.isJumping && this.canStomp) { this.dy = 28; this.canStomp = false; playNote(100, 'sawtooth', 0.3, 0.1); }

        this.dy += 0.4; this.y += this.dy; this.x += this.dx;
        
        if (this.speedBoost > 0) {
            this.speedBoost--; this.trail.push({x: this.x, y: this.y});
            if(this.trail.length > 6) this.trail.shift();
        } else this.trail = [];

        // Borders
        if (this.y < 0) { this.y = 0; this.dy = 1; }
        if (this.x < 0) this.x = 0;
        if (this.x > (canvas.width / zoom) - this.w) this.x = (canvas.width / zoom) - this.w;

        platforms.forEach(p => {
            if(this.x + this.w > p.x && this.x < p.x + p.w) {
                if(this.dy > 0 && this.y + this.h > p.y && this.y < p.y + 20) { this.y = p.y - this.h; this.dy = 0; this.isJumping = false; }
                if(this.dy < 0 && this.y < p.y + p.h && this.y > p.y + p.h - 20) { this.y = p.y + p.h; this.dy = 0; }
            }
        });
        if(this.x < other.x + other.w && this.x + this.w > other.x && Math.abs(this.y - other.y) < 40) {
            if(this.x < other.x) this.x = other.x - this.w; else this.x = other.x + other.w;
        }
    }
    draw() {
        ctx.save(); ctx.translate(this.x + this.w/2, this.y + this.h/2); ctx.rotate(this.rotation);
        this.trail.forEach((t, i) => {
            ctx.globalAlpha = i/12; ctx.fillStyle = this.pNum === 1 ? p1Color : p2Color;
            ctx.fillRect(-this.w/2 - (this.x - t.x), -this.h/2 - (this.y - t.y), this.w, this.h);
        });
        ctx.globalAlpha = 1; ctx.fillStyle = this.pNum === 1 ? p1Color : p2Color;
        ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
        ctx.strokeStyle = 'black'; ctx.lineWidth = 5; ctx.strokeRect(-this.w/2, -this.h/2, this.w, this.h);
        ctx.fillStyle = 'white'; let ex = this.face === 1 ? 25 : -45; ctx.fillRect(ex, -20, 20, 20);
        ctx.restore();
    }
}

const p1 = new Player(200, 400, {up:'KeyW', left:'KeyA', right:'KeyD', down:'KeyS', dash:'ShiftLeft'}, 1);
const p2 = new Player(1100, 400, {up:'ArrowUp', left:'ArrowLeft', right:'ArrowRight', down:'ArrowDown', dash:'Enter'}, 2);
let platforms = [];

function startBattle() {
    showMenu('none');
    platforms = [
        { x: 0, y: (canvas.height/zoom)-100, w: canvas.width/zoom, h: 100 }, // Ground
        { x: 150, y: (canvas.height/zoom)*0.6, w: 350, h: 40 },
        { x: (canvas.width/zoom)-500, y: (canvas.height/zoom)*0.6, w: 350, h: 40 },
        { x: (canvas.width/zoom)*0.35, y: (canvas.height/zoom)*0.35, w: 400, h: 40 } // Center High
    ];
    gameState = 'PLAYING'; startMusic();
    setTimeout(spawnOrb, 5000);
    setTimeout(triggerVortex, 15000);
}

function spawnOrb() {
    if(gameState !== 'PLAYING') return;
    powerup = { x: Math.random()*((canvas.width/zoom)-100), y: Math.random()*((canvas.height/zoom)-300), active: true };
}

function triggerVortex() {
    if(gameState !== 'PLAYING') return;
    vortex.active = true; vortex.x = (canvas.width/zoom)/2; vortex.y = (canvas.height/zoom)*0.45;
    vortex.target = Math.random() > 0.5 ? p1 : p2;
    setTimeout(() => { vortex.active = false; vortex.target = null; setTimeout(triggerVortex, 20000); }, 4000);
}

function drawPlatform(p) {
    ctx.fillStyle = '#5d4037'; ctx.fillRect(p.x, p.y, p.w, p.h); // Dirt
    ctx.fillStyle = '#4caf50'; ctx.fillRect(p.x, p.y, p.w, 15); // Grass
    // Details
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    for(let i=0; i<p.w; i+=40) ctx.fillRect(p.x+i, p.y+20, 15, 10);
}

function loop() {
    ctx.setTransform(1, 0, 0, 1, 0, 0); 
    let sky = ctx.createLinearGradient(0,0,0,canvas.height); sky.addColorStop(0, '#4cc9f0'); sky.addColorStop(1, '#caf0f8');
    ctx.fillStyle = sky; ctx.fillRect(0,0,canvas.width, canvas.height);
    
    ctx.scale(zoom, zoom);
    
    clouds.forEach(c => {
        c.x += c.s; if(c.x > 2000) c.x = -200;
        ctx.fillStyle = 'white'; ctx.globalAlpha = 0.4;
        ctx.fillRect(c.x, c.y, c.w, 30); ctx.fillRect(c.x+20, c.y-15, c.w-40, 15);
    });
    ctx.globalAlpha = 1;

    if(gameState === 'PLAYING') {
        p1.update(p2); p2.update(p1);
        if(vortex.active) {
            vortex.angle += 0.15;
            ctx.strokeStyle = '#9c27b0'; ctx.lineWidth = 15; ctx.beginPath();
            ctx.arc(vortex.x, vortex.y, 100 + Math.sin(Date.now()/100)*15, vortex.angle, vortex.angle + 4.5); ctx.stroke();
        }
        if(powerup.active) {
            ctx.fillStyle = '#fffa00'; ctx.beginPath(); ctx.arc(powerup.x+25, powerup.y+25, 25, 0, 6.28); ctx.fill();
            [p1, p2].forEach(p => { if(Math.hypot(p.x+60-powerup.x, p.y+35-powerup.y) < 60) { powerup.active = false; p.speedBoost = 400; playNote(800, 'sine', 0.5, 0.1); setTimeout(spawnOrb, 15000); } });
        }
        [ [p1, p2], [p2, p1] ].forEach(([atk, vic]) => {
            if(atk.dy > 0 && atk.y + atk.h > vic.y && atk.y < vic.y && atk.x + atk.w > vic.x && atk.x < vic.x + vic.w) {
                atk.score++; if(atk.score >= winLimit) { gameState = 'WIN'; document.getElementById('win-screen').classList.remove('hidden'); document.getElementById('win-txt').innerText = `WINNER!`; }
                else { p1.reset(); p2.reset(); vortex.active = false; powerup.active = false; }
            }
        });
    }
    platforms.forEach(drawPlatform);
    p1.draw(); p2.draw();
    for(let i=0; i<winLimit; i++) {
        ctx.fillStyle = i < p1.score ? p1Color : 'rgba(0,0,0,0.1)'; ctx.fillRect(((canvas.width/zoom)/2)-180+i*40, 40, 30, 30);
        ctx.fillStyle = i < p2.score ? p2Color : 'rgba(0,0,0,0.1)'; ctx.fillRect(((canvas.width/zoom)/2)+60+i*40, 40, 30, 30);
    }
    requestAnimationFrame(loop);
}
window.onkeydown = e => keys[e.code] = true; window.onkeyup = e => keys[e.code] = false; loop();
</script>
</body>
</html>

```


**Would you like me to add a "Shadow" underneath the players that grows larger as they get closer to the ground?**
